/*
 * Interface wrapper code.
 *
 * Generated by SIP 4.9.1-snapshot-20091015 on Mon Nov 16 19:36:49 2009
 */

#include "sipAPIlibserial.h"

#line 5 "SerialPort.sip"
#include <SerialPort.h>
#line 12 "siplibserialSerialPort.cpp"

#line 4 "string.sip"
#include <string>
#include <iostream>
#line 17 "siplibserialSerialPort.cpp"
#line 5 "SerialPort.sip"
#include <SerialPort.h>
#line 20 "siplibserialSerialPort.cpp"
#line 23 "stdexcept.sip"
#include <stdexcept>
#line 23 "siplibserialSerialPort.cpp"
#line 354 "vector.sip"
#include <vector>
#line 26 "siplibserialSerialPort.cpp"
#line 5 "SerialPort.sip"
#include <SerialPort.h>
#line 29 "siplibserialSerialPort.cpp"
#line 38 "stdexcept.sip"
#include <stdexcept>
#line 32 "siplibserialSerialPort.cpp"
#line 5 "SerialPort.sip"
#include <SerialPort.h>
#line 35 "siplibserialSerialPort.cpp"
#line 5 "SerialPort.sip"
#include <SerialPort.h>
#line 38 "siplibserialSerialPort.cpp"
#line 5 "SerialPort.sip"
#include <SerialPort.h>
#line 41 "siplibserialSerialPort.cpp"


extern "C" {static PyObject *meth_SerialPort_Open(PyObject *, PyObject *);}
static PyObject *meth_SerialPort_Open(PyObject *sipSelf, PyObject *sipArgs)
{
    int sipArgsParsed = 0;

    {
        SerialPort::BaudRate a0 = SerialPort::BAUD_DEFAULT;
        SerialPort::CharacterSize a1 = SerialPort::CHAR_SIZE_DEFAULT;
        SerialPort::Parity a2 = SerialPort::PARITY_DEFAULT;
        SerialPort::StopBits a3 = SerialPort::STOP_BITS_DEFAULT;
        SerialPort::FlowControl a4 = SerialPort::FLOW_CONTROL_DEFAULT;
        SerialPort *sipCpp;

        if (sipParseArgs(&sipArgsParsed,sipArgs,"B|EEEEE",&sipSelf,sipType_SerialPort,&sipCpp,sipType_SerialPort_BaudRate,&a0,sipType_SerialPort_CharacterSize,&a1,sipType_SerialPort_Parity,&a2,sipType_SerialPort_StopBits,&a3,sipType_SerialPort_FlowControl,&a4))
        {
            try
            {
            sipCpp->Open(a0,a1,a2,a3,a4);
            }
            catch (SerialPort::AlreadyOpen &sipExceptionRef)
            {
                /* Hope that there is a valid copy ctor. */
                SerialPort::AlreadyOpen *sipExceptionCopy = new SerialPort::AlreadyOpen(sipExceptionRef);

                sipRaiseTypeException(sipType_SerialPort_AlreadyOpen,sipExceptionCopy);

                return NULL;
            }
            catch (SerialPort::OpenFailed &sipExceptionRef)
            {
                /* Hope that there is a valid copy ctor. */
                SerialPort::OpenFailed *sipExceptionCopy = new SerialPort::OpenFailed(sipExceptionRef);

                sipRaiseTypeException(sipType_SerialPort_OpenFailed,sipExceptionCopy);

                return NULL;
            }
            catch (SerialPort::UnsupportedBaudRate &sipExceptionRef)
            {
                /* Hope that there is a valid copy ctor. */
                SerialPort::UnsupportedBaudRate *sipExceptionCopy = new SerialPort::UnsupportedBaudRate(sipExceptionRef);

                sipRaiseTypeException(sipType_SerialPort_UnsupportedBaudRate,sipExceptionCopy);

                return NULL;
            }
            catch (std::invalid_argument &sipExceptionRef)
            {
                /* Hope that there is a valid copy ctor. */
                std::invalid_argument *sipExceptionCopy = new std::invalid_argument(sipExceptionRef);

                sipRaiseTypeException(sipType_std_invalid_argument,sipExceptionCopy);

                return NULL;
            }

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipArgsParsed,sipName_SerialPort,sipName_Open);

    return NULL;
}


extern "C" {static PyObject *meth_SerialPort_IsOpen(PyObject *, PyObject *);}
static PyObject *meth_SerialPort_IsOpen(PyObject *sipSelf, PyObject *sipArgs)
{
    int sipArgsParsed = 0;

    {
        SerialPort *sipCpp;

        if (sipParseArgs(&sipArgsParsed,sipArgs,"B",&sipSelf,sipType_SerialPort,&sipCpp))
        {
            bool sipRes;

            try
            {
            sipRes = sipCpp->IsOpen();
            }
            catch (...)
            {
                sipRaiseUnknownException();
                return NULL;
            }

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipArgsParsed,sipName_SerialPort,sipName_IsOpen);

    return NULL;
}


extern "C" {static PyObject *meth_SerialPort_Close(PyObject *, PyObject *);}
static PyObject *meth_SerialPort_Close(PyObject *sipSelf, PyObject *sipArgs)
{
    int sipArgsParsed = 0;

    {
        SerialPort *sipCpp;

        if (sipParseArgs(&sipArgsParsed,sipArgs,"B",&sipSelf,sipType_SerialPort,&sipCpp))
        {
            try
            {
            sipCpp->Close();
            }
            catch (SerialPort::NotOpen &sipExceptionRef)
            {
                /* Hope that there is a valid copy ctor. */
                SerialPort::NotOpen *sipExceptionCopy = new SerialPort::NotOpen(sipExceptionRef);

                sipRaiseTypeException(sipType_SerialPort_NotOpen,sipExceptionCopy);

                return NULL;
            }

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipArgsParsed,sipName_SerialPort,sipName_Close);

    return NULL;
}


extern "C" {static PyObject *meth_SerialPort_SetBaudRate(PyObject *, PyObject *);}
static PyObject *meth_SerialPort_SetBaudRate(PyObject *sipSelf, PyObject *sipArgs)
{
    int sipArgsParsed = 0;

    {
        SerialPort::BaudRate a0;
        SerialPort *sipCpp;

        if (sipParseArgs(&sipArgsParsed,sipArgs,"BE",&sipSelf,sipType_SerialPort,&sipCpp,sipType_SerialPort_BaudRate,&a0))
        {
            try
            {
            sipCpp->SetBaudRate(a0);
            }
            catch (SerialPort::UnsupportedBaudRate &sipExceptionRef)
            {
                /* Hope that there is a valid copy ctor. */
                SerialPort::UnsupportedBaudRate *sipExceptionCopy = new SerialPort::UnsupportedBaudRate(sipExceptionRef);

                sipRaiseTypeException(sipType_SerialPort_UnsupportedBaudRate,sipExceptionCopy);

                return NULL;
            }
            catch (SerialPort::NotOpen &sipExceptionRef)
            {
                /* Hope that there is a valid copy ctor. */
                SerialPort::NotOpen *sipExceptionCopy = new SerialPort::NotOpen(sipExceptionRef);

                sipRaiseTypeException(sipType_SerialPort_NotOpen,sipExceptionCopy);

                return NULL;
            }
            catch (std::invalid_argument &sipExceptionRef)
            {
                /* Hope that there is a valid copy ctor. */
                std::invalid_argument *sipExceptionCopy = new std::invalid_argument(sipExceptionRef);

                sipRaiseTypeException(sipType_std_invalid_argument,sipExceptionCopy);

                return NULL;
            }

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipArgsParsed,sipName_SerialPort,sipName_SetBaudRate);

    return NULL;
}


extern "C" {static PyObject *meth_SerialPort_GetBaudRate(PyObject *, PyObject *);}
static PyObject *meth_SerialPort_GetBaudRate(PyObject *sipSelf, PyObject *sipArgs)
{
    int sipArgsParsed = 0;

    {
        SerialPort *sipCpp;

        if (sipParseArgs(&sipArgsParsed,sipArgs,"B",&sipSelf,sipType_SerialPort,&sipCpp))
        {
            SerialPort::BaudRate sipRes;

            try
            {
            sipRes = sipCpp->GetBaudRate();
            }
            catch (SerialPort::NotOpen &sipExceptionRef)
            {
                /* Hope that there is a valid copy ctor. */
                SerialPort::NotOpen *sipExceptionCopy = new SerialPort::NotOpen(sipExceptionRef);

                sipRaiseTypeException(sipType_SerialPort_NotOpen,sipExceptionCopy);

                return NULL;
            }
            catch (std::runtime_error &sipExceptionRef)
            {
                /* Hope that there is a valid copy ctor. */
                std::runtime_error *sipExceptionCopy = new std::runtime_error(sipExceptionRef);

                sipRaiseTypeException(sipType_std_runtime_error,sipExceptionCopy);

                return NULL;
            }

            return sipConvertFromEnum(sipRes,sipType_SerialPort_BaudRate);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipArgsParsed,sipName_SerialPort,sipName_GetBaudRate);

    return NULL;
}


extern "C" {static PyObject *meth_SerialPort_SetCharSize(PyObject *, PyObject *);}
static PyObject *meth_SerialPort_SetCharSize(PyObject *sipSelf, PyObject *sipArgs)
{
    int sipArgsParsed = 0;

    {
        SerialPort::CharacterSize a0;
        SerialPort *sipCpp;

        if (sipParseArgs(&sipArgsParsed,sipArgs,"BE",&sipSelf,sipType_SerialPort,&sipCpp,sipType_SerialPort_CharacterSize,&a0))
        {
            try
            {
            sipCpp->SetCharSize(a0);
            }
            catch (SerialPort::NotOpen &sipExceptionRef)
            {
                /* Hope that there is a valid copy ctor. */
                SerialPort::NotOpen *sipExceptionCopy = new SerialPort::NotOpen(sipExceptionRef);

                sipRaiseTypeException(sipType_SerialPort_NotOpen,sipExceptionCopy);

                return NULL;
            }
            catch (std::invalid_argument &sipExceptionRef)
            {
                /* Hope that there is a valid copy ctor. */
                std::invalid_argument *sipExceptionCopy = new std::invalid_argument(sipExceptionRef);

                sipRaiseTypeException(sipType_std_invalid_argument,sipExceptionCopy);

                return NULL;
            }

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipArgsParsed,sipName_SerialPort,sipName_SetCharSize);

    return NULL;
}


extern "C" {static PyObject *meth_SerialPort_GetCharSize(PyObject *, PyObject *);}
static PyObject *meth_SerialPort_GetCharSize(PyObject *sipSelf, PyObject *sipArgs)
{
    int sipArgsParsed = 0;

    {
        SerialPort *sipCpp;

        if (sipParseArgs(&sipArgsParsed,sipArgs,"B",&sipSelf,sipType_SerialPort,&sipCpp))
        {
            SerialPort::CharacterSize sipRes;

            try
            {
            sipRes = sipCpp->GetCharSize();
            }
            catch (SerialPort::NotOpen &sipExceptionRef)
            {
                /* Hope that there is a valid copy ctor. */
                SerialPort::NotOpen *sipExceptionCopy = new SerialPort::NotOpen(sipExceptionRef);

                sipRaiseTypeException(sipType_SerialPort_NotOpen,sipExceptionCopy);

                return NULL;
            }

            return sipConvertFromEnum(sipRes,sipType_SerialPort_CharacterSize);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipArgsParsed,sipName_SerialPort,sipName_GetCharSize);

    return NULL;
}


extern "C" {static PyObject *meth_SerialPort_SetParity(PyObject *, PyObject *);}
static PyObject *meth_SerialPort_SetParity(PyObject *sipSelf, PyObject *sipArgs)
{
    int sipArgsParsed = 0;

    {
        SerialPort::Parity a0;
        SerialPort *sipCpp;

        if (sipParseArgs(&sipArgsParsed,sipArgs,"BE",&sipSelf,sipType_SerialPort,&sipCpp,sipType_SerialPort_Parity,&a0))
        {
            try
            {
            sipCpp->SetParity(a0);
            }
            catch (SerialPort::NotOpen &sipExceptionRef)
            {
                /* Hope that there is a valid copy ctor. */
                SerialPort::NotOpen *sipExceptionCopy = new SerialPort::NotOpen(sipExceptionRef);

                sipRaiseTypeException(sipType_SerialPort_NotOpen,sipExceptionCopy);

                return NULL;
            }
            catch (std::invalid_argument &sipExceptionRef)
            {
                /* Hope that there is a valid copy ctor. */
                std::invalid_argument *sipExceptionCopy = new std::invalid_argument(sipExceptionRef);

                sipRaiseTypeException(sipType_std_invalid_argument,sipExceptionCopy);

                return NULL;
            }

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipArgsParsed,sipName_SerialPort,sipName_SetParity);

    return NULL;
}


extern "C" {static PyObject *meth_SerialPort_GetParity(PyObject *, PyObject *);}
static PyObject *meth_SerialPort_GetParity(PyObject *sipSelf, PyObject *sipArgs)
{
    int sipArgsParsed = 0;

    {
        SerialPort *sipCpp;

        if (sipParseArgs(&sipArgsParsed,sipArgs,"B",&sipSelf,sipType_SerialPort,&sipCpp))
        {
            SerialPort::Parity sipRes;

            try
            {
            sipRes = sipCpp->GetParity();
            }
            catch (SerialPort::NotOpen &sipExceptionRef)
            {
                /* Hope that there is a valid copy ctor. */
                SerialPort::NotOpen *sipExceptionCopy = new SerialPort::NotOpen(sipExceptionRef);

                sipRaiseTypeException(sipType_SerialPort_NotOpen,sipExceptionCopy);

                return NULL;
            }

            return sipConvertFromEnum(sipRes,sipType_SerialPort_Parity);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipArgsParsed,sipName_SerialPort,sipName_GetParity);

    return NULL;
}


extern "C" {static PyObject *meth_SerialPort_SetNumOfStopBits(PyObject *, PyObject *);}
static PyObject *meth_SerialPort_SetNumOfStopBits(PyObject *sipSelf, PyObject *sipArgs)
{
    int sipArgsParsed = 0;

    {
        SerialPort::StopBits a0;
        SerialPort *sipCpp;

        if (sipParseArgs(&sipArgsParsed,sipArgs,"BE",&sipSelf,sipType_SerialPort,&sipCpp,sipType_SerialPort_StopBits,&a0))
        {
            try
            {
            sipCpp->SetNumOfStopBits(a0);
            }
            catch (SerialPort::NotOpen &sipExceptionRef)
            {
                /* Hope that there is a valid copy ctor. */
                SerialPort::NotOpen *sipExceptionCopy = new SerialPort::NotOpen(sipExceptionRef);

                sipRaiseTypeException(sipType_SerialPort_NotOpen,sipExceptionCopy);

                return NULL;
            }
            catch (std::invalid_argument &sipExceptionRef)
            {
                /* Hope that there is a valid copy ctor. */
                std::invalid_argument *sipExceptionCopy = new std::invalid_argument(sipExceptionRef);

                sipRaiseTypeException(sipType_std_invalid_argument,sipExceptionCopy);

                return NULL;
            }

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipArgsParsed,sipName_SerialPort,sipName_SetNumOfStopBits);

    return NULL;
}


extern "C" {static PyObject *meth_SerialPort_GetNumOfStopBits(PyObject *, PyObject *);}
static PyObject *meth_SerialPort_GetNumOfStopBits(PyObject *sipSelf, PyObject *sipArgs)
{
    int sipArgsParsed = 0;

    {
        SerialPort *sipCpp;

        if (sipParseArgs(&sipArgsParsed,sipArgs,"B",&sipSelf,sipType_SerialPort,&sipCpp))
        {
            SerialPort::StopBits sipRes;

            try
            {
            sipRes = sipCpp->GetNumOfStopBits();
            }
            catch (SerialPort::NotOpen &sipExceptionRef)
            {
                /* Hope that there is a valid copy ctor. */
                SerialPort::NotOpen *sipExceptionCopy = new SerialPort::NotOpen(sipExceptionRef);

                sipRaiseTypeException(sipType_SerialPort_NotOpen,sipExceptionCopy);

                return NULL;
            }

            return sipConvertFromEnum(sipRes,sipType_SerialPort_StopBits);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipArgsParsed,sipName_SerialPort,sipName_GetNumOfStopBits);

    return NULL;
}


extern "C" {static PyObject *meth_SerialPort_SetFlowControl(PyObject *, PyObject *);}
static PyObject *meth_SerialPort_SetFlowControl(PyObject *sipSelf, PyObject *sipArgs)
{
    int sipArgsParsed = 0;

    {
        SerialPort::FlowControl a0;
        SerialPort *sipCpp;

        if (sipParseArgs(&sipArgsParsed,sipArgs,"BE",&sipSelf,sipType_SerialPort,&sipCpp,sipType_SerialPort_FlowControl,&a0))
        {
            try
            {
            sipCpp->SetFlowControl(a0);
            }
            catch (SerialPort::NotOpen &sipExceptionRef)
            {
                /* Hope that there is a valid copy ctor. */
                SerialPort::NotOpen *sipExceptionCopy = new SerialPort::NotOpen(sipExceptionRef);

                sipRaiseTypeException(sipType_SerialPort_NotOpen,sipExceptionCopy);

                return NULL;
            }
            catch (std::invalid_argument &sipExceptionRef)
            {
                /* Hope that there is a valid copy ctor. */
                std::invalid_argument *sipExceptionCopy = new std::invalid_argument(sipExceptionRef);

                sipRaiseTypeException(sipType_std_invalid_argument,sipExceptionCopy);

                return NULL;
            }

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipArgsParsed,sipName_SerialPort,sipName_SetFlowControl);

    return NULL;
}


extern "C" {static PyObject *meth_SerialPort_GetFlowControl(PyObject *, PyObject *);}
static PyObject *meth_SerialPort_GetFlowControl(PyObject *sipSelf, PyObject *sipArgs)
{
    int sipArgsParsed = 0;

    {
        SerialPort *sipCpp;

        if (sipParseArgs(&sipArgsParsed,sipArgs,"B",&sipSelf,sipType_SerialPort,&sipCpp))
        {
            SerialPort::FlowControl sipRes;

            try
            {
            sipRes = sipCpp->GetFlowControl();
            }
            catch (SerialPort::NotOpen &sipExceptionRef)
            {
                /* Hope that there is a valid copy ctor. */
                SerialPort::NotOpen *sipExceptionCopy = new SerialPort::NotOpen(sipExceptionRef);

                sipRaiseTypeException(sipType_SerialPort_NotOpen,sipExceptionCopy);

                return NULL;
            }

            return sipConvertFromEnum(sipRes,sipType_SerialPort_FlowControl);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipArgsParsed,sipName_SerialPort,sipName_GetFlowControl);

    return NULL;
}


extern "C" {static PyObject *meth_SerialPort_IsDataAvailable(PyObject *, PyObject *);}
static PyObject *meth_SerialPort_IsDataAvailable(PyObject *sipSelf, PyObject *sipArgs)
{
    int sipArgsParsed = 0;

    {
        SerialPort *sipCpp;

        if (sipParseArgs(&sipArgsParsed,sipArgs,"B",&sipSelf,sipType_SerialPort,&sipCpp))
        {
            bool sipRes;

            try
            {
            sipRes = sipCpp->IsDataAvailable();
            }
            catch (SerialPort::NotOpen &sipExceptionRef)
            {
                /* Hope that there is a valid copy ctor. */
                SerialPort::NotOpen *sipExceptionCopy = new SerialPort::NotOpen(sipExceptionRef);

                sipRaiseTypeException(sipType_SerialPort_NotOpen,sipExceptionCopy);

                return NULL;
            }

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipArgsParsed,sipName_SerialPort,sipName_IsDataAvailable);

    return NULL;
}


extern "C" {static PyObject *meth_SerialPort_ReadByte(PyObject *, PyObject *);}
static PyObject *meth_SerialPort_ReadByte(PyObject *sipSelf, PyObject *sipArgs)
{
    int sipArgsParsed = 0;

    {
        unsigned a0 = 0;
        SerialPort *sipCpp;

        if (sipParseArgs(&sipArgsParsed,sipArgs,"B|u",&sipSelf,sipType_SerialPort,&sipCpp,&a0))
        {
            unsigned char sipRes;

            try
            {
            sipRes = sipCpp->ReadByte(a0);
            }
            catch (SerialPort::NotOpen &sipExceptionRef)
            {
                /* Hope that there is a valid copy ctor. */
                SerialPort::NotOpen *sipExceptionCopy = new SerialPort::NotOpen(sipExceptionRef);

                sipRaiseTypeException(sipType_SerialPort_NotOpen,sipExceptionCopy);

                return NULL;
            }
            catch (SerialPort::ReadTimeout &sipExceptionRef)
            {
                /* Hope that there is a valid copy ctor. */
                SerialPort::ReadTimeout *sipExceptionCopy = new SerialPort::ReadTimeout(sipExceptionRef);

                sipRaiseTypeException(sipType_SerialPort_ReadTimeout,sipExceptionCopy);

                return NULL;
            }
            catch (std::runtime_error &sipExceptionRef)
            {
                /* Hope that there is a valid copy ctor. */
                std::runtime_error *sipExceptionCopy = new std::runtime_error(sipExceptionRef);

                sipRaiseTypeException(sipType_std_runtime_error,sipExceptionCopy);

                return NULL;
            }

            return SIPBytes_FromStringAndSize((char *)&sipRes,1);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipArgsParsed,sipName_SerialPort,sipName_ReadByte);

    return NULL;
}


extern "C" {static PyObject *meth_SerialPort_Read(PyObject *, PyObject *);}
static PyObject *meth_SerialPort_Read(PyObject *sipSelf, PyObject *sipArgs)
{
    int sipArgsParsed = 0;

    {
        SerialPort::DataBuffer * a0;
        int a0State = 0;
        unsigned a1 = 0;
        unsigned a2 = 0;
        SerialPort *sipCpp;

        if (sipParseArgs(&sipArgsParsed,sipArgs,"BJ1|uu",&sipSelf,sipType_SerialPort,&sipCpp,sipType_std_vector_1300,&a0,&a0State,&a1,&a2))
        {
            try
            {
            sipCpp->Read(*a0,a1,a2);
            }
            catch (SerialPort::NotOpen &sipExceptionRef)
            {

            sipReleaseType(a0,sipType_std_vector_1300,a0State);
                /* Hope that there is a valid copy ctor. */
                SerialPort::NotOpen *sipExceptionCopy = new SerialPort::NotOpen(sipExceptionRef);

                sipRaiseTypeException(sipType_SerialPort_NotOpen,sipExceptionCopy);

                return NULL;
            }
            catch (SerialPort::ReadTimeout &sipExceptionRef)
            {

            sipReleaseType(a0,sipType_std_vector_1300,a0State);
                /* Hope that there is a valid copy ctor. */
                SerialPort::ReadTimeout *sipExceptionCopy = new SerialPort::ReadTimeout(sipExceptionRef);

                sipRaiseTypeException(sipType_SerialPort_ReadTimeout,sipExceptionCopy);

                return NULL;
            }
            catch (std::runtime_error &sipExceptionRef)
            {

            sipReleaseType(a0,sipType_std_vector_1300,a0State);
                /* Hope that there is a valid copy ctor. */
                std::runtime_error *sipExceptionCopy = new std::runtime_error(sipExceptionRef);

                sipRaiseTypeException(sipType_std_runtime_error,sipExceptionCopy);

                return NULL;
            }

            sipReleaseType(a0,sipType_std_vector_1300,a0State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipArgsParsed,sipName_SerialPort,sipName_Read);

    return NULL;
}


extern "C" {static PyObject *meth_SerialPort_ReadLine(PyObject *, PyObject *);}
static PyObject *meth_SerialPort_ReadLine(PyObject *sipSelf, PyObject *sipArgs)
{
    int sipArgsParsed = 0;

    {
        unsigned a0;
        char a1;
        SerialPort *sipCpp;

        if (sipParseArgs(&sipArgsParsed,sipArgs,"Buc",&sipSelf,sipType_SerialPort,&sipCpp,&a0,&a1))
        {
            std::string *sipRes;

            try
            {
            sipRes = new std::string(sipCpp->ReadLine(a0,a1));
            }
            catch (SerialPort::NotOpen &sipExceptionRef)
            {
                /* Hope that there is a valid copy ctor. */
                SerialPort::NotOpen *sipExceptionCopy = new SerialPort::NotOpen(sipExceptionRef);

                sipRaiseTypeException(sipType_SerialPort_NotOpen,sipExceptionCopy);

                return NULL;
            }
            catch (SerialPort::ReadTimeout &sipExceptionRef)
            {
                /* Hope that there is a valid copy ctor. */
                SerialPort::ReadTimeout *sipExceptionCopy = new SerialPort::ReadTimeout(sipExceptionRef);

                sipRaiseTypeException(sipType_SerialPort_ReadTimeout,sipExceptionCopy);

                return NULL;
            }
            catch (std::runtime_error &sipExceptionRef)
            {
                /* Hope that there is a valid copy ctor. */
                std::runtime_error *sipExceptionCopy = new std::runtime_error(sipExceptionRef);

                sipRaiseTypeException(sipType_std_runtime_error,sipExceptionCopy);

                return NULL;
            }

            return sipConvertFromNewType(sipRes,sipType_std_string,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipArgsParsed,sipName_SerialPort,sipName_ReadLine);

    return NULL;
}


extern "C" {static PyObject *meth_SerialPort_WriteByte(PyObject *, PyObject *);}
static PyObject *meth_SerialPort_WriteByte(PyObject *sipSelf, PyObject *sipArgs)
{
    int sipArgsParsed = 0;

    {
        unsigned char a0;
        SerialPort *sipCpp;

        if (sipParseArgs(&sipArgsParsed,sipArgs,"Bc",&sipSelf,sipType_SerialPort,&sipCpp,&a0))
        {
            try
            {
            sipCpp->WriteByte(a0);
            }
            catch (SerialPort::NotOpen &sipExceptionRef)
            {
                /* Hope that there is a valid copy ctor. */
                SerialPort::NotOpen *sipExceptionCopy = new SerialPort::NotOpen(sipExceptionRef);

                sipRaiseTypeException(sipType_SerialPort_NotOpen,sipExceptionCopy);

                return NULL;
            }
            catch (std::runtime_error &sipExceptionRef)
            {
                /* Hope that there is a valid copy ctor. */
                std::runtime_error *sipExceptionCopy = new std::runtime_error(sipExceptionRef);

                sipRaiseTypeException(sipType_std_runtime_error,sipExceptionCopy);

                return NULL;
            }

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipArgsParsed,sipName_SerialPort,sipName_WriteByte);

    return NULL;
}


extern "C" {static PyObject *meth_SerialPort_Write(PyObject *, PyObject *);}
static PyObject *meth_SerialPort_Write(PyObject *sipSelf, PyObject *sipArgs)
{
    int sipArgsParsed = 0;

    {
        const SerialPort::DataBuffer * a0;
        int a0State = 0;
        SerialPort *sipCpp;

        if (sipParseArgs(&sipArgsParsed,sipArgs,"BJ1",&sipSelf,sipType_SerialPort,&sipCpp,sipType_std_vector_1300,&a0,&a0State))
        {
            try
            {
            sipCpp->Write(*a0);
            }
            catch (SerialPort::NotOpen &sipExceptionRef)
            {

            sipReleaseType(const_cast<SerialPort::DataBuffer *>(a0),sipType_std_vector_1300,a0State);
                /* Hope that there is a valid copy ctor. */
                SerialPort::NotOpen *sipExceptionCopy = new SerialPort::NotOpen(sipExceptionRef);

                sipRaiseTypeException(sipType_SerialPort_NotOpen,sipExceptionCopy);

                return NULL;
            }
            catch (std::runtime_error &sipExceptionRef)
            {

            sipReleaseType(const_cast<SerialPort::DataBuffer *>(a0),sipType_std_vector_1300,a0State);
                /* Hope that there is a valid copy ctor. */
                std::runtime_error *sipExceptionCopy = new std::runtime_error(sipExceptionRef);

                sipRaiseTypeException(sipType_std_runtime_error,sipExceptionCopy);

                return NULL;
            }

            sipReleaseType(const_cast<SerialPort::DataBuffer *>(a0),sipType_std_vector_1300,a0State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const std::string * a0;
        int a0State = 0;
        SerialPort *sipCpp;

        if (sipParseArgs(&sipArgsParsed,sipArgs,"BJ1",&sipSelf,sipType_SerialPort,&sipCpp,sipType_std_string,&a0,&a0State))
        {
            try
            {
            sipCpp->Write(*a0);
            }
            catch (SerialPort::NotOpen &sipExceptionRef)
            {

            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);
                /* Hope that there is a valid copy ctor. */
                SerialPort::NotOpen *sipExceptionCopy = new SerialPort::NotOpen(sipExceptionRef);

                sipRaiseTypeException(sipType_SerialPort_NotOpen,sipExceptionCopy);

                return NULL;
            }
            catch (std::runtime_error &sipExceptionRef)
            {

            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);
                /* Hope that there is a valid copy ctor. */
                std::runtime_error *sipExceptionCopy = new std::runtime_error(sipExceptionRef);

                sipRaiseTypeException(sipType_std_runtime_error,sipExceptionCopy);

                return NULL;
            }

            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipArgsParsed,sipName_SerialPort,sipName_Write);

    return NULL;
}


extern "C" {static PyObject *meth_SerialPort_SetDtr(PyObject *, PyObject *);}
static PyObject *meth_SerialPort_SetDtr(PyObject *sipSelf, PyObject *sipArgs)
{
    int sipArgsParsed = 0;

    {
        bool a0 = 1;
        SerialPort *sipCpp;

        if (sipParseArgs(&sipArgsParsed,sipArgs,"B|b",&sipSelf,sipType_SerialPort,&sipCpp,&a0))
        {
            try
            {
            sipCpp->SetDtr(a0);
            }
            catch (SerialPort::NotOpen &sipExceptionRef)
            {
                /* Hope that there is a valid copy ctor. */
                SerialPort::NotOpen *sipExceptionCopy = new SerialPort::NotOpen(sipExceptionRef);

                sipRaiseTypeException(sipType_SerialPort_NotOpen,sipExceptionCopy);

                return NULL;
            }
            catch (std::runtime_error &sipExceptionRef)
            {
                /* Hope that there is a valid copy ctor. */
                std::runtime_error *sipExceptionCopy = new std::runtime_error(sipExceptionRef);

                sipRaiseTypeException(sipType_std_runtime_error,sipExceptionCopy);

                return NULL;
            }

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipArgsParsed,sipName_SerialPort,sipName_SetDtr);

    return NULL;
}


extern "C" {static PyObject *meth_SerialPort_GetDtr(PyObject *, PyObject *);}
static PyObject *meth_SerialPort_GetDtr(PyObject *sipSelf, PyObject *sipArgs)
{
    int sipArgsParsed = 0;

    {
        SerialPort *sipCpp;

        if (sipParseArgs(&sipArgsParsed,sipArgs,"B",&sipSelf,sipType_SerialPort,&sipCpp))
        {
            bool sipRes;

            try
            {
            sipRes = sipCpp->GetDtr();
            }
            catch (SerialPort::NotOpen &sipExceptionRef)
            {
                /* Hope that there is a valid copy ctor. */
                SerialPort::NotOpen *sipExceptionCopy = new SerialPort::NotOpen(sipExceptionRef);

                sipRaiseTypeException(sipType_SerialPort_NotOpen,sipExceptionCopy);

                return NULL;
            }
            catch (std::runtime_error &sipExceptionRef)
            {
                /* Hope that there is a valid copy ctor. */
                std::runtime_error *sipExceptionCopy = new std::runtime_error(sipExceptionRef);

                sipRaiseTypeException(sipType_std_runtime_error,sipExceptionCopy);

                return NULL;
            }

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipArgsParsed,sipName_SerialPort,sipName_GetDtr);

    return NULL;
}


extern "C" {static PyObject *meth_SerialPort_SetRts(PyObject *, PyObject *);}
static PyObject *meth_SerialPort_SetRts(PyObject *sipSelf, PyObject *sipArgs)
{
    int sipArgsParsed = 0;

    {
        bool a0 = 1;
        SerialPort *sipCpp;

        if (sipParseArgs(&sipArgsParsed,sipArgs,"B|b",&sipSelf,sipType_SerialPort,&sipCpp,&a0))
        {
            try
            {
            sipCpp->SetRts(a0);
            }
            catch (SerialPort::NotOpen &sipExceptionRef)
            {
                /* Hope that there is a valid copy ctor. */
                SerialPort::NotOpen *sipExceptionCopy = new SerialPort::NotOpen(sipExceptionRef);

                sipRaiseTypeException(sipType_SerialPort_NotOpen,sipExceptionCopy);

                return NULL;
            }
            catch (std::runtime_error &sipExceptionRef)
            {
                /* Hope that there is a valid copy ctor. */
                std::runtime_error *sipExceptionCopy = new std::runtime_error(sipExceptionRef);

                sipRaiseTypeException(sipType_std_runtime_error,sipExceptionCopy);

                return NULL;
            }

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipArgsParsed,sipName_SerialPort,sipName_SetRts);

    return NULL;
}


extern "C" {static PyObject *meth_SerialPort_GetRts(PyObject *, PyObject *);}
static PyObject *meth_SerialPort_GetRts(PyObject *sipSelf, PyObject *sipArgs)
{
    int sipArgsParsed = 0;

    {
        SerialPort *sipCpp;

        if (sipParseArgs(&sipArgsParsed,sipArgs,"B",&sipSelf,sipType_SerialPort,&sipCpp))
        {
            bool sipRes;

            try
            {
            sipRes = sipCpp->GetRts();
            }
            catch (SerialPort::NotOpen &sipExceptionRef)
            {
                /* Hope that there is a valid copy ctor. */
                SerialPort::NotOpen *sipExceptionCopy = new SerialPort::NotOpen(sipExceptionRef);

                sipRaiseTypeException(sipType_SerialPort_NotOpen,sipExceptionCopy);

                return NULL;
            }
            catch (std::runtime_error &sipExceptionRef)
            {
                /* Hope that there is a valid copy ctor. */
                std::runtime_error *sipExceptionCopy = new std::runtime_error(sipExceptionRef);

                sipRaiseTypeException(sipType_std_runtime_error,sipExceptionCopy);

                return NULL;
            }

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipArgsParsed,sipName_SerialPort,sipName_GetRts);

    return NULL;
}


extern "C" {static PyObject *meth_SerialPort_GetCts(PyObject *, PyObject *);}
static PyObject *meth_SerialPort_GetCts(PyObject *sipSelf, PyObject *sipArgs)
{
    int sipArgsParsed = 0;

    {
        SerialPort *sipCpp;

        if (sipParseArgs(&sipArgsParsed,sipArgs,"B",&sipSelf,sipType_SerialPort,&sipCpp))
        {
            bool sipRes;

            try
            {
            sipRes = sipCpp->GetCts();
            }
            catch (SerialPort::NotOpen &sipExceptionRef)
            {
                /* Hope that there is a valid copy ctor. */
                SerialPort::NotOpen *sipExceptionCopy = new SerialPort::NotOpen(sipExceptionRef);

                sipRaiseTypeException(sipType_SerialPort_NotOpen,sipExceptionCopy);

                return NULL;
            }
            catch (std::runtime_error &sipExceptionRef)
            {
                /* Hope that there is a valid copy ctor. */
                std::runtime_error *sipExceptionCopy = new std::runtime_error(sipExceptionRef);

                sipRaiseTypeException(sipType_std_runtime_error,sipExceptionCopy);

                return NULL;
            }

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipArgsParsed,sipName_SerialPort,sipName_GetCts);

    return NULL;
}


extern "C" {static PyObject *meth_SerialPort_GetDsr(PyObject *, PyObject *);}
static PyObject *meth_SerialPort_GetDsr(PyObject *sipSelf, PyObject *sipArgs)
{
    int sipArgsParsed = 0;

    {
        SerialPort *sipCpp;

        if (sipParseArgs(&sipArgsParsed,sipArgs,"B",&sipSelf,sipType_SerialPort,&sipCpp))
        {
            bool sipRes;

            try
            {
            sipRes = sipCpp->GetDsr();
            }
            catch (SerialPort::NotOpen &sipExceptionRef)
            {
                /* Hope that there is a valid copy ctor. */
                SerialPort::NotOpen *sipExceptionCopy = new SerialPort::NotOpen(sipExceptionRef);

                sipRaiseTypeException(sipType_SerialPort_NotOpen,sipExceptionCopy);

                return NULL;
            }
            catch (std::runtime_error &sipExceptionRef)
            {
                /* Hope that there is a valid copy ctor. */
                std::runtime_error *sipExceptionCopy = new std::runtime_error(sipExceptionRef);

                sipRaiseTypeException(sipType_std_runtime_error,sipExceptionCopy);

                return NULL;
            }

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipArgsParsed,sipName_SerialPort,sipName_GetDsr);

    return NULL;
}


/* Cast a pointer to a type somewhere in its superclass hierarchy. */
extern "C" {static void *cast_SerialPort(void *, const sipTypeDef *);}
static void *cast_SerialPort(void *ptr, const sipTypeDef *targetType)
{
    if (targetType == sipType_SerialPort)
        return ptr;

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_SerialPort(void *, int);}
static void release_SerialPort(void *sipCppV,int)
{
    delete reinterpret_cast<SerialPort *>(sipCppV);
}


extern "C" {static void dealloc_SerialPort(sipSimpleWrapper *);}
static void dealloc_SerialPort(sipSimpleWrapper *sipSelf)
{
    if (sipIsPyOwned(sipSelf))
    {
        release_SerialPort(sipSelf->u.cppPtr,0);
    }
}


extern "C" {static void *init_SerialPort(sipSimpleWrapper *, PyObject *, PyObject **, int *);}
static void *init_SerialPort(sipSimpleWrapper *, PyObject *sipArgs, PyObject **, int *sipArgsParsed)
{
    SerialPort *sipCpp = 0;

    if (!sipCpp)
    {
        const std::string * a0;
        int a0State = 0;

        if (sipParseArgs(sipArgsParsed,sipArgs,"J1",sipType_std_string,&a0,&a0State))
        {
            try
            {
            sipCpp = new SerialPort(*a0);
            }
            catch (...)
            {

            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);
                sipRaiseUnknownException();
                return NULL;
            }

            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);
        }
    }

    return sipCpp;
}


static PyMethodDef methods_SerialPort[] = {
    {SIP_MLNAME_CAST(sipName_Close), meth_SerialPort_Close, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_GetBaudRate), meth_SerialPort_GetBaudRate, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_GetCharSize), meth_SerialPort_GetCharSize, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_GetCts), meth_SerialPort_GetCts, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_GetDsr), meth_SerialPort_GetDsr, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_GetDtr), meth_SerialPort_GetDtr, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_GetFlowControl), meth_SerialPort_GetFlowControl, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_GetNumOfStopBits), meth_SerialPort_GetNumOfStopBits, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_GetParity), meth_SerialPort_GetParity, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_GetRts), meth_SerialPort_GetRts, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_IsDataAvailable), meth_SerialPort_IsDataAvailable, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_IsOpen), meth_SerialPort_IsOpen, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_Open), meth_SerialPort_Open, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_Read), meth_SerialPort_Read, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_ReadByte), meth_SerialPort_ReadByte, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_ReadLine), meth_SerialPort_ReadLine, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_SetBaudRate), meth_SerialPort_SetBaudRate, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_SetCharSize), meth_SerialPort_SetCharSize, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_SetDtr), meth_SerialPort_SetDtr, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_SetFlowControl), meth_SerialPort_SetFlowControl, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_SetNumOfStopBits), meth_SerialPort_SetNumOfStopBits, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_SetParity), meth_SerialPort_SetParity, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_SetRts), meth_SerialPort_SetRts, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_Write), meth_SerialPort_Write, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_WriteByte), meth_SerialPort_WriteByte, METH_VARARGS, NULL}
};

static sipEnumMemberDef enummembers_SerialPort[] = {
    {sipName_BAUD_110, SerialPort::BAUD_110, 2},
    {sipName_BAUD_115200, SerialPort::BAUD_115200, 2},
    {sipName_BAUD_1200, SerialPort::BAUD_1200, 2},
    {sipName_BAUD_134, SerialPort::BAUD_134, 2},
    {sipName_BAUD_150, SerialPort::BAUD_150, 2},
    {sipName_BAUD_1800, SerialPort::BAUD_1800, 2},
    {sipName_BAUD_19200, SerialPort::BAUD_19200, 2},
    {sipName_BAUD_200, SerialPort::BAUD_200, 2},
    {sipName_BAUD_230400, SerialPort::BAUD_230400, 2},
    {sipName_BAUD_2400, SerialPort::BAUD_2400, 2},
    {sipName_BAUD_300, SerialPort::BAUD_300, 2},
    {sipName_BAUD_38400, SerialPort::BAUD_38400, 2},
    {sipName_BAUD_460800, SerialPort::BAUD_460800, 2},
    {sipName_BAUD_4800, SerialPort::BAUD_4800, 2},
    {sipName_BAUD_50, SerialPort::BAUD_50, 2},
    {sipName_BAUD_57600, SerialPort::BAUD_57600, 2},
    {sipName_BAUD_600, SerialPort::BAUD_600, 2},
    {sipName_BAUD_75, SerialPort::BAUD_75, 2},
    {sipName_BAUD_9600, SerialPort::BAUD_9600, 2},
    {sipName_BAUD_DEFAULT, SerialPort::BAUD_DEFAULT, 2},
    {sipName_CHAR_SIZE_5, SerialPort::CHAR_SIZE_5, 3},
    {sipName_CHAR_SIZE_6, SerialPort::CHAR_SIZE_6, 3},
    {sipName_CHAR_SIZE_7, SerialPort::CHAR_SIZE_7, 3},
    {sipName_CHAR_SIZE_8, SerialPort::CHAR_SIZE_8, 3},
    {sipName_CHAR_SIZE_DEFAULT, SerialPort::CHAR_SIZE_DEFAULT, 3},
    {sipName_FLOW_CONTROL_DEFAULT, SerialPort::FLOW_CONTROL_DEFAULT, 4},
    {sipName_FLOW_CONTROL_HARD, SerialPort::FLOW_CONTROL_HARD, 4},
    {sipName_FLOW_CONTROL_NONE, SerialPort::FLOW_CONTROL_NONE, 4},
    {sipName_PARITY_DEFAULT, SerialPort::PARITY_DEFAULT, 7},
    {sipName_PARITY_EVEN, SerialPort::PARITY_EVEN, 7},
    {sipName_PARITY_NONE, SerialPort::PARITY_NONE, 7},
    {sipName_PARITY_ODD, SerialPort::PARITY_ODD, 7},
    {sipName_STOP_BITS_1, SerialPort::STOP_BITS_1, 9},
    {sipName_STOP_BITS_2, SerialPort::STOP_BITS_2, 9},
    {sipName_STOP_BITS_DEFAULT, SerialPort::STOP_BITS_DEFAULT, 9},
};


sipClassTypeDef sipTypeDef_libserial_SerialPort = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_SerialPort,
        {0}
    },
    {
        sipNameNr_SerialPort,
        {0, 0, 1},
        25, methods_SerialPort,
        35, enummembers_SerialPort,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    -1,
    -1,
    0,
    0,
    init_SerialPort,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_SerialPort,
    0,
    0,
    0,
    release_SerialPort,
    cast_SerialPort,
    0,
    0,
    0
};
